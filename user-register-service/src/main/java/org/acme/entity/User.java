package org.acme.entity;import io.smallrye.mutiny.Uni;import io.smallrye.mutiny.Multi;import io.vertx.mutiny.pgclient.PgPool;import io.vertx.mutiny.sqlclient.Row;import io.vertx.mutiny.sqlclient.RowSet;import io.vertx.mutiny.sqlclient.Tuple;public class User {	public Long id;	public String userId;	public String userPw;	public String email;	public User() {	}	public User(Long id, String userId) {		this.id = id;		this.userId = userId;	}	public User(Long id, String userId, String userPw, String email) {		this.id = id;		this.userId = userId;		this.userPw = userPw;		this.email = email;	}	public static Multi<User> findAll(PgPool pgPool) {		return pgPool.query("SELECT id, userId FROM users ODERR BY userId ASC").execute()				.onItem().transformToMulti(set -> Multi.createFrom().iterable(set))				.onItem().transform(User::from);	}	public static Uni<User> findById(PgPool pgPool, Long id) {		return pgPool.preparedQuery("SELECT id, userId FROM users WHERE id=$1 ").execute(Tuple.of(id))				.onItem().transform(RowSet::iterator)				.onItem().transform(iterator -> iterator.hasNext() ? from(iterator.next()) : null);	}	public Uni<Long> save(PgPool pgPool) {		return pgPool.preparedQuery("INSERT INTO users (userId) VALUES ($1) RETURNING id ").execute(Tuple.of(userId, id))				.onItem().transform(pgRowSet -> pgRowSet.iterator().next().getLong("id"));	}	public Uni<Boolean> update(PgPool pgPool) {		return pgPool.preparedQuery("UPDATE users SET userId = $1 WHERE id = $2").execute(Tuple.of(userId, id))				.onItem().transform(pgRowSet -> pgRowSet.rowCount() == 1);	}	public static Uni<Boolean>	private static User from(Row row) {		return new User(row.getLong("id"), row.getString("userId"));	}}